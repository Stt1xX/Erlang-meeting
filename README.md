# Функциональное программирование - ЛР №1

## Введение

- Студент ***Рамеев Тимур Ильгизович 367511***
- Вариант ***8, 21***

## Задачи

### Problem 8 (Largest Product in a Series)

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 * 9 * 8 * 9 = 5832
> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?


Для первого задания я отдельно создал [файл](task8), в котором хранится 1000-значное число. Также стоит отметить, что модульная и монолитные реализации отличаются между собой не только функционалом, который я использовал в них, но и логикой решения.

- [***Монолитное решение***](src/task1/monolit_task1.erl) - простой пробег по строке из символов с подменой максимального произведения (в случае нахождения такового)
-  [***Модульное решение***](src/task1/module_task1.erl) - здесь я для начала отделли все "участки" числа по нулям друг от друга и исключил те, размер которых меньше заданного (13). Затем пробегался по каждому участку и также как и в монолитном решении искал максимальное произведение.


### Problem 21 (Amicable Numbers)

> Let *d(n)* be defined as the sum of proper divisors of *n* (numbers less than which divide evenly into *n*).
> If *d(a) = b* and *d(b) = a*, where *a != b*, then *a* and *b* are an amicable pair and each of *a* and *b* are called amicable numbers.
> Evaluate the sum of all the amicable numbers under 10000.

Касаемо второй задачи, хочется сперва сказать, что [***Модульная реализация***](src/task2/module_task2.erl) выглядит горазадо лучше чем [***Монолитная реализация***](src/task2/monolit_task2.erl) с точки зрения эффективности, потому, что в ней мы работаем с структурой данных map а не list. Связанно это с тем, что обход всей структуры данных через рекурсию (хвостовую рекурсию) возможен только для структуры данных list. По логике решения достаточно схожи.

Для каждого элемента в диапазоне от 1 до *n* (10000) находим сумму делителей в простом цикле. Затем проходимся по составленной map или list (в зависимости от реализации) и для каждого элемента смотрим, есть ли дружественный. Подсчитываем сумму дружественных элементов. Вот и все!

## Вывод

1. Встроенные функции для работы со списками такие как foldl, map, filter очень помогают, делают код более читабельным и структурированным. 
2. Хвостовые рекурсии, без которых в функциональных языках не обойтись достаточно мощный механизм вкупе с паттерн-матчингом, позволяют писать мощные и в тоже время компактные функции.
3. Также хочется отметить примичательную структуру case statement-а и похожих по структуре if и try catch statement-ов
4. Использовал макросы, очень похожи на макросы языка C
5. Можно отметить guards дополнительная защита для функций, которая применяется во время pattern matching процесса.
6. Ну и, наверное, последнее - анонимные лямбда выражения - очереденая парадигма функциональных языков, тоже была активно использована в ходе выполнения лабораторной работы.